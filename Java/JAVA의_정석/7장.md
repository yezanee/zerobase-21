> 자바의 정석을 보고 공부한 내용을 정리한 글이다.
</br> 
> **KEY WORD** </br>
> 상속, 오버라이딩, super, super(), 패키지, import, 제어자, 접근 제어자 </br>

</br>

# 1. 상속(inheritance)

## 1.1 상속의 정의와 장점

**상속**
- 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것 </br>

**왜 이용할까?**
- 적은 양의 코드로 새로운 클래스 작성 가능
- 코드를 공통적으로 관리 → 코드의 추가 및 변경 용이
- 코드의 재사용성 ↑
- 코드의 중복 제거 → 생산성, 유지보수에 큰 기여

**구현 방법**

```java
class Child extends Parent {
	// ...
}
````

- 새로 작성하고자 하는 클래스 이름( **자손 클래스** ) : `Child`
- 상속 받고자 하는 기존 클래스 이름( **조상 클래스** ) : `Parent`

> **조상 클래스** : 부모 클래스, 상위 클래스, 기반 클래스
> **자손 클래스** : 자식 클래스, 하위 클래스, 파생된 클래스

</br>


**자손 클래스는 조상 클래스의 모든 멤버를 상속받기 때문에**, Child 클래스는 Parent 클래스의 멤버들을 포함한다고 할 수 있다. 벤다이어그램으로 나타내면 밑의 7-2 그림과 같다.

![](https://velog.velcdn.com/images/yezanee/post/f017dd2c-7f11-4962-9e09-d24108d14374/image.png)

</br>

```java
class Parent {
	int age
}

class Child extends Parent { }
```
→ Parent 클래스에 age라는 정수형 변수 멤버 변수로 추가하면, 자손 클래스는 조상의 멤버를 모두 상속받아 Child 클래스는 **자동적으로 age라는 멤버변수가 추가**된 것과 같은 효과 얻음.

</br>

```java
class Parent {
	int age
}

class Child extends Parent {
	void play() {
    	System.out.println("놀자~");
    }
}
```
→ Child 클래스에 play() 메서드를 추가해도 **조상 클래스인 Parent에겐 아무 영향도 주지 않음**

</br>

> - 생성자와 초기화 블럭은 상속 X, 멤버만 상속
> - 자손 클래스의 멤버 개수 >= 조상 클래스의 멤버 개수

</br>

```java
class Parent { }
class Child extends Parent { }
class Child2 extends Parent { }
```

→ Child와 Child2가 모두 Parent 클래스 상속 받음
→ Child와 Child2는 서로 아무런 관계 X

Child와 Child2에 공통적으로 추가되어야 하는 멤버가 있다면 두 클래스에 따로 따로 추가하기 보다, 공통조상인 Parent에 추가하는 것이 좋다. → **코드 중복 줄어듦**

</br>

```java
class Parent { }
class Child extends Parent { }
class Child2 extends Parent { }
class GrandChild extends Child { }
```

→ GrandChild는 Child를 상속 받음.
→ Child(직접 조상)의 자손이면서 동시에 Parent(간접 조상)의 자손

```java
class Parent {
	int age;
}
class Child extends Parent { }
class Child2 extends Parent { }
class GrandChild extends Child { }
```

→ Parent에 age 멤버변수 추가
→ Child, Child2, GrandChild 모두 age 멤버변수 추가

</br>

```java
class Tv {
    boolean power;  // 전원상태 (on/off)
    int channel;    // 채널
    
    void power() { power = !power; }
    void channelUp() { ++channel; }
    void channelDown() { --channel; }
}

class CaptionTv extends Tv {
    boolean caption;    // 캡션상태 (on/off)
    void displayCaption(String text) {
        if (caption) {  // 캡션 상태가 on(true)일 때만 text를 보여 준다.
            System.out.println(text);
        }
    }
}

public class Main {
    public static void main(String[] args) {
        CaptionTv ctv = new CaptionTv();
        ctv.channel = 10;   // 조상 클래스로부터 상속받은 멤버
        ctv.channelUp();    // 조상 클래스로부터 상속받은 멤버
        System.out.println(ctv.channel); // 11 출력
        ctv.displayCaption("Hello, World"); // 출력 안됨
        ctv.caption = true;
        ctv.displayCaption("Hello, World"); // 출력
    }
}
```

> **자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.**

</br>

## 1.2 클래스간의 관계 - 포함관계

클래스를 재사용하는 또 다른 방법 → `포함 관계`

```java
class Circle {
	int x;	// 원점의 x좌표
    int y;	// 원점의 y좌표
    int r;	// 반지름 (radius)
}
```
⇧ 원을 표현하기 위한 클래스

```java
class Point {
	int x;	// x좌표
    int y;	// y좌표
}
```
⇧ 좌표상의 한 점을 다루기 위한 클래스

```java
class Circle {
	Point c = new Point();	// 원점
    int r;
}
```
⇧ Point 클래스를 재사용해서 Circle 클래스 작성

→ 클래스를 작성하기 쉽고 코드가 더 간결해진다. 단위 클래스 별로 코드가 나뉘어 작성되어 있기 때문에 코드를 관리 하는데도 수월하다.

</br>

## 1.3 클래스간의 관계 결정하기

> **상속관계 vs 포함관계**

```java
class Circle {
	Point c = new Point();
    int r;
}
```

↓ ( 포함관계 대신 상속관계 )

```java
class Circle extends Point {
	int r;
}
```

> 원(Circle)은 점(Point)**이다.** (is-a) → **상속 관계**
> 원(Circle)은 점(Point)을 **가지고 있다.** (has-a) → **포함 관계**

위의 원의 예시와 같은 경우엔 `가지고 있다` 의 경우가 더 적합하므로 포함관계이다.

```java
class Main {
    public static void main(String[] args) {
        Point[] p = {
                new Point(100, 150),
                new Point(140, 50),
                new Point(200, 100)
        };

        Triangle t = new Triangle(p);
        Circle c = new Circle(new Point(150, 150), 50);
        /*
        Point p = new Point(150, 150);
        Circle c = new Circle(p, 50);
        위 두 문장을 한 문장으로 적은 것이다.
        */
        

        t.draw();   // 삼각형을 그린다.
        c.draw();   // 원을 그린다.
    }
}

class Shape {
    String color = "black";
    void draw() {
        System.out.printf("[color = %s] %n", color);
    }
}

class Point {
    int x;
    int y;

    Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
    Point() {
        this(0,0);
    }

    String getXY() {
        return "(" + x + "," + y + ")"; // x와 y의 값을 문자열로 반환
    }

}

class Circle extends Shape { // 원은 도형이다. (상속관계)
    Point center;   // 원의 원점 좌표 (원은 점을 가지고 있다. - 포함관계)
    int r;

    Circle() {
        this(new Point(0,0), 100);  // Circle(Point center, int r)을 호출
    }

    Circle(Point center, int r) {
        this.center = center;
        this.r = r;
    }

    void draw() { // 원을 그리는 대신 원의 정보를 출력하도록 했다 (오버라이딩)
        System.out.printf("[center = (%d, %d), r = %d, color = %s] %n", center.x, center.y, r, color);
    }
}

class Triangle extends Shape { // 삼각형은 도형이다. (상속관계)
    Point[] p = new Point[3]; // 삼각형은 점을 가지고 있다. 포함관계)

    Triangle(Point[] p) {
        this.p = p;
    }

    void draw() {
        System.out.printf("[p1 = %s, p2 = %s, p3 = %s, color = %s]%n", p[0].getXY(), p[1].getXY(), p[2].getXY(), color);
    }
}
```

<실행 결과>


![](https://velog.velcdn.com/images/yezanee/post/a448d1fc-0fcf-4b04-9ea0-6654f3dbd639/image.png)

</br>

```java
class Main {
    public static void main(String[] args) {
        Deck d = new Deck(); // 카드 한벌(Deck)을 만든다.
        Card c = d.pick(0); // 섞기 전에 제일 위의 카드를 뽑는다.
        System.out.println(c); // System.out.println(c.toString()); 과 같다.

        d.shuffle();
        c = d.pick(0);
        System.out.println(c);
    }
}

class Deck {
    final int CARD_NUM = 52; // 카드의 개수
    Card cardArr[] = new Card[CARD_NUM]; // Card 객체 배열을 포함

    Deck() { // Deck의 카드를 초기화한다.
        int i = 0;

        for(int k = Card.KIND_MAX; k > 0; k--) {
            for(int n = 0; n < Card.NUM_MAX; n++) {
                cardArr[i++] = new Card(k, n+1);
            }
        }
    }

    Card pick(int index) {
        return cardArr[index]; // 객체의 주소가 반환된다.
    }

    Card pick() {   // Deck에서 카드 하나를 선택한다.
        int index = (int)(Math.random() * CARD_NUM);
        return pick(index);
    }

    void shuffle() {    // 카드의 순서를 섞는다.
        for (int i = 0; i < cardArr.length; i++) {
            int r = (int)(Math.random() * CARD_NUM);

            Card temp = cardArr[i];
            cardArr[i] = cardArr[r];
            cardArr[r] = temp;
        }
        // 카드 한 벌의 첫번째 카드부터 순서대로 임의로 위치에 있는 카드와 위치를 서로 바꾸는 방식으로 카드 섞음
        // random 이용 -> 매 실행마다 결과 다르게 나타남
    }
}   // Deck 클래스의 끝

class Card {
    static final int KIND_MAX = 4;  // 카드 무늬의 수
    static final int NUM_MAX = 13;  // 무늬별 카드 수

    static final int SPADE = 4;
    static final int DIAMOND = 3;
    static final int HEART = 2;
    static final int CLOVER = 1;
    int kind;
    int number;

    Card() {
        this(SPADE, 1);
    }

    Card(int kind, int number) {
        this.kind = kind;
        this.number = number;
    }

    public String toString() { // 인스턴스의 정보를 문자열로 반환
        String[] kinds = {"", "CLOVER", "HEART", "DIAMOND", "SPADE"};
        String numbers = "0123456789XJQK"; // 숫자 10은 X로 표현
        return "kind : " + kinds[this.kind] + ", number : " + numbers.charAt(this.number);
    }
} // Card 클래스의 끝
```

<실행 결과>

![](https://velog.velcdn.com/images/yezanee/post/aa6bd6d0-12df-4a58-92c3-02b4ddc45574/image.png)

</br>
</br>

## 1.4 단일 상속

- 자바에서는 오직 하나의 조상 클래스만 상속 받는 것이 가능한 단일 상속만을 허용한다.

```java
class TVCR extends TV, VCR { // 에러. 조상은 하나만 허용된다.
	// ...
}
```

**자바는 왜 다중상속을 허용하지 않을까?**
- 다중 상속을 허용하면 복합적인 기능을 가진 클래스를 쉽게 작성할 수 있다.
- 하지만 클래스간의 관계가 매우 복잡해지고
- 서로 다른 클래스로부터 상속받은 멤버간의 이름이 같은 경우 구별할 수 없다.
- 단일 상속이 클래스 간의 관계가 보다 명확해지고, 코드를 더욱 신뢰할 수 있게 만들어준다.

```java
class Tv {
    boolean power;  // 전원상태 (on/off)
    int channel;    // 채널

    void power();   { power = !power; }
    void channelUp()  { ++channel; }
    void channelDown()  { --channel; }

}

class VCR {
    boolean power;  // 전원상태 (on/off)
    int counter = 0;
    void power()    { power = !power; }
    void play()     { /* 내용 생략 */ }
    void stop()     { /* 내용 생략 */ }
    void rew()      { /* 내용 생략 */ }
    void ff()       { /* 내용 생략 */ }
}

class TVCR extends Tv { // Tv 클래스와 상속관계
    VCR vcr = new VCR(); // VCR 클래스와 포함관계
    int counter = vcr.counter;

    void play() {
        vcr.play(); // VCR 클래스의 메서드를 가져와 이용할 수 있다.
    }

    void stop() {
        vcr.stop();
    }

    void rew() {
        vcr.rew();
    }

    void ff() {
        vcr.ff();
    }
}
```

</br>
</br>

## 1.5 Object 클래스 - 모든 클래스의 조상

- Object 클래스는 모든 클래스 상속계층도의 최상위에 있는 조상클래스
- 다른 클래스로부터 상속받지 않은 클래스는 자동적으로 Object 클래스로부터 상속받게 함

```java
class Tv {
	...
}
```

위 코드를 컴파일하면 컴파일러는 위의 코드를 자동적으로 `extends Object` 를 추가하여 Tv 클래스가 Object 클래스로부터 상속 받도록 한다.

```java
class tv extends Object {
	...
}
```

</br>
</br>

# 2. 오버라이딩 (overriding)

## 2.1 오버라이딩이란?

- 조상클래스로부터 상속받은 메서드의 내용을 변경하는 것
- 상속받은 메서드를 그대로 이용하기도 하지만, 자손 클래스 자신에 맞게 변경하는 경우 이용

```java
class Point {
	int x;
    int y;
    
    String getLocation() {
    	return "x :" + x + ", y :" + y;
    }
}

class Point3D extends Point {
	int z;
    
    String getLocation() { // 오버라이딩
    	return "x :" + x + ", y :" + y + ", z :" + z;
    }
}
```

- 자손클래스인 Point3D에서는 3차원 좌표계의 한 점을 표현한 것이기 때문에 자신의 클래스에 맞게 변수 z를 추가하여 출력하도록 오버라이딩 했다.
- getLocation() 메서드를 이용했을 때 2차원과 3차원의 차이만 있을 뿐 좌표를 출력하는 기능은 동일하다. 따라서 새로운 메서드를 정의하기 보다는 오버라이딩 하는 것이 바른 선택이다.

</br>
</br>

## 2.2 오버라이딩의 조건

> 자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와
> - **이름이 같아야 한다.**
> - **매개변수가 같아야 한다.**
> - **반환타입이 같아야 한다.**
>
> 한마디로 요약하면 선언부가 서로 일치해야 한다.
> 하지만, 접근 제어자와 예외는 제한된 조건 하에서만 다르게 변경할 수 있다.


**1. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.**
- 조상 클래스에 정의된 메서드의 접근 제어자: protected
- 오버라이딩하는 자손 클래스의 메서드의 접근 제어자: protected, public
- 접근 제어자의 접근 범위: public > protected > (default) > private

</br>

**2. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.**

```java
class Parent {
	void parentMethod() throws IOException, SQLException {
    	...
    }
}

class Child extends Parent {
	void parentMethod() throws IOException {
    	...
    }
    ...
}
```

↑ 자손 클래스의 예외 개수가 더 적으므로 올바르게 오버라이딩 되었다.

>**주의**
>
>단순히 예외의 개수가 적기만 한다고 되는 것은 아니다.

```java
class Child extends Parent {
	void parentMethod() throws Exception {
    	...
    }
    ...
}
```

- 위의 코드와 같은 경우에는 예외의 개수는 더 적지만 Exception은 모든 예외의 최고 조상이므로 가장 많은 수의 예외를 던질 수 있도록 선언한 것이다. 따라서 위와 같은 경우는 잘못 오버라이딩 한 것이다.

</br>

> **정리**
> 1. 접근제어자를 조상 클래스의 메서드보다 좁은 범위로 변경 불가능
> 2. 예외는 조상 클래스의 메서드보다 많이 선언할 수 없음
> 3. 인스턴스 메서드를 static 메서드 또는 그 반대로 변경할 수 없다.

</br>

> **Q. 조상 클래스에 정의된 static 메서드를 자손 클래스에서 똑같은 이름의 static 메서드로 정의할 수 있나요?**
>
> A. 가능. 하지만 이런 경우 오버라이딩이 아니라 같은 이름의 새로운 메서드를 정의한 것과 같음. static 메서드는 클래스의 이름으로도 충분히 구별이 가능하기 때문. (ex. 자손클래스이름.메서드이름(), 조상클래스이름.메서드이름()) static 메서드는 자신이 정의된 클래스에 묶여있는 것과 같음.


</br>
</br>

## 2.3 오버로딩 vs 오버라이딩

> **오버로딩(overloading)** : 기존에 없는 새로운 메서드를 정의하는 것 (new)
> **오버라이딩(overriding)** : 상속받은 메서드의 내용을 변경하는 것 (change, modify)

아래 코드의 오버로딩과 오버라이딩을 구별해보자!

```java
class Parent {
	void parentMethod() {}
}

class Child extends Parent {
	void parentMethod() {} // 오버라이딩
    void parentMethod(int i) {} // 오버로딩
    
    void childMethod() {}
    void childMethod(int i) {} // 오버로딩
    void childMethod() {} // 에러. 중복정의
}
```

</br>
</br>

## 2.4 super

- 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수
- 멤버변수 vs 지역변수 → 이름 같을 때 this로 구별
- 조상 클래스 멤버 vs 자손 클래스 멤버 → 이름 같을 때 super로 구별

```java
class Main {
    public static void main(String[] args) {
        Child c = new Child();
        c.method();
    }
}

class Parent {
    int x = 10;
}

 class Child extends Parent {
    void method() {
        System.out.println("x= " + x);
        System.out.println("this.x= " + this.x);
        System.out.println("super.x= " + super.x);
    }
 }
 ```
 
 ↑ `x = this.x = super.x`  모두 같은 변수를 의미!
 
 ```java
 class Main {
    public static void main(String[] args) {
        Child c = new Child();
        c.method();
    }
}

class Parent {
    int x = 10;
}

 class Child extends Parent {
 	int x = 20;
    
    void method() {
        System.out.println("x= " + x);
        System.out.println("this.x= " + this.x);
        System.out.println("super.x= " + super.x);
    }
 }
 ```
 
 ↑ 같은 이름의 멤버변수가 조상클래스와 자손 클래스 둘다 존재
 
 - super.x = 조상 클래스로부터 상속받은 멤버변수 x
 - this.x = 자손 클래스에 선언된 멤버변수 x

변수 뿐만 아니라 메서드 역시 super을 써서 호출할 수 있다.

```java
class Point {
	int x;
    int y;
    
    String getLocation() {
    	return "x :" + x + ", y :" + y;
    }
}

class Point3D extends Point {
	int z;
    
    String getLocation() { // 오버라이딩
    	// return "x :" + x + ", y :" + y + ", z :" + z;
        return super.getLocation() + ", z :" + z; // 조상의 메서드 호출
    }
}
```
↑ 오버라이딩 할때 조상클래스의 getLocation()을 호출하는 코드를 포함
조상클래스의 메서드의 내용에 추가적으로 작업을 덧붙이는 경우라면
이처럼 super을 이용해 조상클래스의 메서드를 포함시키는 것이 좋다. (변경 용이)

</br>
</br>

## 2.5 super() - 조상 클래스의 생성자

- this() : 같은 클래스의 다른 생성자를 호출
- super() : 조상 클래스의 생성자를 호출

> 자손 클래스의 인스턴스 생성
> ↓
> 자손의 멤버와 조상의 멤버가 모두 합쳐진 하나의 인스턴스 생성
> ↓
> 이 때 조상 클래스 멤버의 초기화 작업이 수행 되어야 함
> ↓
> 자손 클래스의 생성자에서 조상 클래스의 생성자 호출 되어야 함
> ↓
> 모든 클래스의 최고 조상인 Object 클래스의 생성자인 Object()까지 가서야 끝남

- **생성자의 첫 줄에서 조상 클래스의 생성자를 호출해야하는 이유**
- 자손클래스이 멤버가 조상 클래스의 멤버를 사용할 수도 있으므로 조상의 멤버들이 먼저 초기화되어 있어야 함

> Object 클래스를 제외한 모든 클래스의 생성자 첫 줄에 생성자, this() 또는 super()를 호출해야한다. 그렇지 않으면 컴파일러가 자동적으로 'super();'를 생성자의 첫 줄에 삽입한다.

> **1. 클래스** - 어떤 클래스의 인스턴스를 생성할 것인가?
> **2. 생성자** - 선택한 클래스의 어떤 생성자를 이용해서 인스턴스를 생성할 것인가?


```java
class Main {
    public static void main(String[] args) {
        Point3D p3 = new Point3D(1,2,3);
    }
}

class Point {
	int x;
    int y;
    
    Point(int x, int y) {
    	this.x = x;
        this.y = y;
    }
    
    String getLocation() {
    	return "x :" + x + ", y :" + y;
    }
}

class Point3D extends Point {
	int z;
    
    Point3D(int x, int y, int z) {
    	
        /* 생성자의 첫 줄에서 다른 생성자를 호출하기 않기 때문에
        컴파일러가 'super();'를 여기에 삽입한다.
        super()는 Point3D의 조상인 Point 클래스의 기본 생성자인
        Point()를 의미한다. */
        
    	this.x = x;
        this.y = y;
        this.z = z;
    }
    
    String getLocation() { // 오버라이딩
    	return "x :" + x + ", y :" + y + ", z :" + z;
    }
}
 ```
 
 <실행 결과>
 **컴파일 에러 발생**
point3D 클래스의 생성자에서 조상 클래스의 생성자인 Point()를 찾을 수 없다.

- Point3D클래스의 생성자의 첫 줄이 생성자를 호출하는 문장이 아니기 때문에 컴파일러는 자동적으로 'super();'를 Point3D 클래스의 생성자 첫 줄에 넣어준다.
- Point3D 클래스의 인스턴스 생성 → 생성자 Point3D(int x, int y, int z) 호출
- 첫 문장인 'super();' 수행
- super() : Point 클래스의 기본 생성자인 Point() 호출
- **그러나, Point 클래스에 생성자 Point() 정의 X → 컴파일에러**
- **해결방법**
 1. Point 클래스에 생성자 Point() 추가
 2. 생성자 Point3D(int x, int y, int z)의 첫줄에서 Point(int x, int y) 호출하도록 변경

</br>

```java
class Main {
    public static void main(String[] args) {
        Point3D p3 = new Point3D();
        System.out.println("p3.x=" + p3.x);
        System.out.println("p3.y = " + p3.y);
        System.out.println("p3.z = " + p3.z);
    }
}

class Point {
    int x = 10;
    int y = 20;

    Point(int x, int y) {
    
    	/* 생성자 첫 줄에서 다른 생성자를 호출하지 않기 때문에
    	컴파일러가 'super();'를 여기에 삽입한다.
    	super()는 Point의 조상인 Object 클래스의
    	기본 생성자인 Object()를 의미한다 */
    
        this.x = x;
        this.y = y;
    }
}

class Point3D extends Point {
    int z = 30;

    Point3D() {
        this(100,200,300);  // Point3D(int x, int y, int x)를 호출한다.
    }
    Point3D(int x, int y, int z) {
        super(x, y);    // Point(int x, int y)를 호출한다.
        this.z = z;
    }

}
```

위의 코드는 아래와 같은 순서로 생성자 호출

`Point3D() → Point3D(int x, int y, int z) → Point(int x, int y) → Object()`

</br>
</br>

# 3. package와 import

## 3.1 패키지

- 서로 관련된 클래스의 묶음
- 클래스를 효율적으로 관리
- 같은 이름의 클래스 일지라도 서로 다른 패키지에 존재하는 것이 가능
- 클래스가 물리적으로 하나의 클래스파일(.class)인 것과 같이 패키지는 물리적으로 하나의 디렉토리다.

</br>

> - 하나의 소스파일에는 첫 번째 문장으로 단 한번의 패키지 선언만을 허용한다.
> - 모든 클래스는 반드시 하나의 패키지에 속해야 한다.
> - 패키지는 점(.)을 구분자로 하여 계층구조로 구성할 수 있다.
> - 패키지는 물리적으로 클래스 파일(.class)을 포함하는 하나의 디렉토리다.

</br>

## 3.2 패키지의 선언

> package 패키지명;

클래스나 인터페이스의 소스파일 맨 위에 위와 같이 한줄만 적어주면 된다.

- 소스파일에서 주석과 공백을 제외한 첫번째 문장이어야 함
- 하나의 소스파일에 단 한번만 선언 가능
- 해당 소스파일에 포함된 모든 클래스나 인터페이스는 선언된 패키지에 속하게 됨
- 클래스명은 소문자로 하는 것이 원칙
- 모든 클래스는 반드시 하나의 패키지 안에 속해야 됨
- 패키지를 선언 하지 않을 때는 자동적으로 이름없는 패키지에 속하게 됨

**'-d' 옵션**
- 소스파일에 지정된 경로를 통해 패키지의 위치를 찾아서 클래스 파일을 생성
- 만일 지정된 패키지와 일치하는 디렉토리가 존재하지 않는다면 자동적으로 생성

ex) `C:\jdk1.8\work>javac	-d	.	packageTest.java`

디렉토리 생성 후, 패키지의 루트 디렉토리를 클래스패스에 포함시킨다.

</br>
</br>

## 3.3 import문

- 다른 패키지의 클래스를 사용하려면 패키지명이 포함된 클래스 이름을 사용해야 한다.
- 하지만, 매번 패키지명을 붙여서 작성하는 것은 불편!
- 클래스의 코드를 작성하기 전에 **import** 문으로 사용하고자 하는 클래스의 패키지를 미리 명시해준다. (패키지명 생략 가능!)
- 역할 : 컴파일러에게 소스파일에 사용된 클래스의 패키지에 대한 정보를 제공

</br>
</br>

## 3.4 import문의 선언

> 일반적인 소스파일(*.java)의 구성은 다음의 순서로 되어있다.
> 1. package문
> 2. import문
> 3. 클래스 선언

import문 선언 방법 ▼
```java
import 패키지명.클래스명;
	또는
import 패키지명.*; // 지정된 패키지에 속하는 모든 클래스 패키지명 없이 사용
```

```java
import java.util.Calendat;
import java.util.Date;
import java.uti;.ArrayList;

// 다음과 같이 한 줄로 표현 가능

import java.util.*;
```

하지만 import 하는 패키지의 수가 많을 때는 어느 클래스가 어느 패키지에 속하는지 구별하기 어렵다.

```java
import.util.*;
import.text.*;

// 다음과 같이 한 줄로 표현은 불가능 (하위 패키지의 클래스까지 포함 X)

import java.*;
```

> **import java.lang.*;**
>
> 이 패키지는 매우 빈번히 사용되는 중요한 클래스들이 속한 패키지이기 때문에
> 따로 import 문으로 지정하지 않아도 된다. (묵시적으로 선언되어 있음)

</br>
</br>

## 3.5 static import문

- static 멤버를 호출할 때 클래스 이름 생략 가능

```java
import static java.lang.Integer.*; // Integer 클래스의 모든 static 메서드
import static java.lang.Math.random; // Math.random()만. 괄호 안붙임.
import static java.lang.System.out; // System.out을 out만으로 참조가능
```

```java
System.out.println(Math.random());
// 다음과 같이 간략히 가능
out.println(random());
```

</br>
</br>

# 4. 제어자 (modifier)
## 4.1 제어자란?

- 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여

> **접근 제어자** : public, protected, default, private
> **그 외** : static, final, abstract, native, transient, synchronized, volatile, strictfp

- 접근제어자 : 네 가지 중 하나만 선택해서 사용 가능
- 그 외 : 하나의 대상에 대해 여러 제어자 조합하여 사용하는 것 가능

</br>
</br>

## 4.2 static - 클래스의, 공통적인

> static이 사용될 수 있는 곳 - 멤버변수, 메서드, 초기화 블럭

| 제어자 | 대상 | 의미 |
|:---:|:---:|:---:|
|static| 멤버변수 | - 모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다. </br> - 클래스 변수는 인스턴스를 생성하지 않고도 사용 가능 하다. </br> - 클래스가 메모리에 로드될 때 생성된다. |
| | 메서드 | - 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다. </br> - static 메서드 내에서는 인스턴스 멤버들을 직접 사용할 수 없다.|

</br>
</br>

## 4.3 final - 마지막의, 변경될 수 없는

> final이 사용될 수 있는 곳 - 클래스, 메서드, 멤버변수, 지역변수

| 제어자 | 대상 | 의미 |
|:---:|:---:|:---:|
|| 클래스 | 변경될 수 없는 클래스, 확장될 수 없는 클래스 </br> final로 지정된 클래스는 다른 클래스의 조상이 될 수 없음 |
|final| 메서드 | 변경될 수 없는 메서드, final로 지정된 메서드는 오버라이딩을 통해 재정의 불가|
| | 멤버변수 | 변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수 됨 |
| | 지역변수 | 변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수 됨 |

**생성자를 이용한 final 멤버 변수의 초기화**

- final이 붙은 변수는 상수이므로, 일반적으로 선언과 초기화를 동시에 함 (ex. final int num = 5;)
- 하지만 인스턴스 변수의 경우 **생성자에서 초기화 되도록 할 수 있음**
- 클래스 내에 매개변수를 갖는 생성자 선언 → 인스턴스를 생성할 때 final이 붙은 멤버변수를 초기화하는데 필요한 값을 생성자의 매개변수로부터 제공받음
- 각 인스턴스마다 final이 붙은 멤버변수가 다른 값 갖도록 하는 것이 가능
- 예를 들어 카드의 경우, 각 카드마다 다른 종류와 숫자를 갖지만 카드가 생성되면 카드의 값이 변경되어서는 안됨
- 52장의 카드 중에서 하나만 잘못 바꿔도 똑같은 카드가 2장이 되는 일이 생기기 때문
- 카드의 값을 바꾸기 보단, **카드의 순서**를 바꾸는 쪽이 안전 (1.3에 있는 코드 참고)

```java
class Card {
    final int NUMBER;   // 상수지만 선언과 함께 초기화 하지 않고
    final String KIND; // 생성자에서 단 한번만 초기화할 수 있다.
    static int width = 100;
    static int height = 250;

    Card(String kind, int num) {
        KIND = kind;
        NUMBER = num;
    }

    Card() {
        this("HEART", 1);
    }

    public String toString() {
        return KIND + " " + NUMBER;
    }
}

class Main {
    public static void main(String[] args) {
        Card c = new Card("HEART", 10);
//        c.NUMBER = 5;
        System.out.println(c.KIND);
        System.out.println(c.NUMBER);
        System.out.println(c);
    }
}
```

<실행 결과>

![](https://velog.velcdn.com/images/yezanee/post/a1226720-48a9-4f39-96ba-b4987b995bd6/image.png)

</br>
</br>

## 4.4 abstract - 추상의, 미완성의

- 메서드의 선언부만 작성하고 실제 수행 내용은 구현하지 않은 추상 메서드를 선언할 때 사용
- 인스턴스 생성 불가능

> abstract가 사용될 수 있는 곳 - 클래스, 메서드

| 제어자 | 대상 | 의미 |
|:---:|:---:|:---:|
|abstract| 클래스 | 클래스 내에 추상 메서드가 선언되어 있음을 의미
| | 메서드 | 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알림 |

후에 더 자세하게 배운다!

</br>
</br>

## 4.5 접근 제어자(access modifier)

- 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할

> 접근 제어자가 사용될 수 있는 곳 - 클래스, 멤버변수, 메서드, 생성자
>
> **private** : 같은 클래스 내에서만 접근이 가능하다.
> **default** : 같은 패키지 내에서만 접근이 가능하다.
> **protected** : 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다.
> **public** : 접근 제한이 전혀 없다.


> **접근 범위 순서**
> public > protected > (default) > private


| 제어자 | 같은 클래스 | 같은 패키지 | 자손클래스 | 전체 |
|:---:|:---:|:---:|:---:|:---:|
|public|O|O|O|O|
|protected|O|O|O||
|(default)|O|O|||
|private|O||||

</br>
</br>

| 대상 | 사용 가능한 접근 제어자 |
|:---:|:---:|
|클래스| public, (default)|
|메서드| public, protected, |
|멤버변수| (default), private|
|지역변수| 없 음 |

</br>
</br>

**접근 제어자를 이용한 캡슐화**

> 접근 제어자를 사용하는 이유
> - 외부로부터 데이터를 보호하기 위해서
> - 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서

</br>

```java
public class Main {
    public static void main(String[] args) {
        Time t = new Time(12, 35, 30);
        System.out.println(t);
//        t.hour = 13;
        t.setHour(t.getHour() + 1); // 현재 시간보다 1시간 후로 변경한다.
        System.out.println(t); // System.out.prinln(t.toString());과 같다.
    }
}

class Time {
    private int hour, minute, second;

    Time(int hour, int minute, int second) {
        setHour(hour);
        setMinute(minute);
        setSecond(second);
    }

    public int getHour()    { return hour; }
    public void setHour(int hour) {
        if (hour < 0 || hour > 23) return;
        this.hour = hour;
    }

    public int getMinute()  { return minute; }
    public void setMinute(int minute) {
        if (minute < 0 || minute > 59) return;
        this.minute = minute;
    }
    public int getSecond()  { return second; }
    public void setSecond(int second) {
        if (second < 0 || second > 59) return;
        this.second = second;
    }
    public String toString() {
        return hour + ":" + minute + ":" + second;
    }
}
```

> Time 클래스의 모든 멤버변수의 접근 제어자를 private로 하고, 이들을 다루기 위한 public 메서드를 추가했다.
> 그래서 't.hour = 13;'과 같이 멤버변수로의 직접적인 접근은 허가되지 않는다.
> **메서드를 통한 접근만이 허용된다.**

</br>

**생성자의 접근 제어자**

- 인스턴스의 생성을 제한
  - 생성자의 접근 제어자를 private → 인스턴스 생성 제한
  - 클래스 내부에 대신 인스턴스를 생성해서 반환해주는 public인 동시에 static인 메서드 제공
  - 외부에서 이 클래스의 인스턴스 사용 가능 (사용 가능한 인스턴스 개수 제한)
  
- 생성자 private → 다른 클래스의 조상이 될 수 없음 

</br>

## 4.6 제어자(modifier)의 조합

| 대상 | 사용 가능한 제어자 |
|:---:|:---:|
| 클래스 | pulic, (default), final, abstract |
| 메서드 | 모든 접근 제어자, final, abstract, static |
| 멤버변수 | 모든 접근 제어자, final, static |
| 지역변수 | final |

</br>

> **제어자를 조합해서 사용할 때 주의해야 할 사항**
>
> **1. 메서드에 static과 abstract를 함께 사용할 수 없다.**
> static 메서드는 몸통이 있는 메서드에만 사용 가능
>
> **2. 클래스에 abstract와 final을 동시에 사용할 수 없다.**
> 클래스에서 사용되는 final은 클래스를 확장할 수 없다는 의미, abstract는 상속을 통해서 완성되어야 한다는 의미이므로 서로 모순
>
> **3. abstract 메서드의 접근 제어자가 private일 수 없다.**
> abstract 메서드는 자손 클래스에서 구현해주어야 하는데 접근 제어자가 private이면 자손 클래스에서 접근할 수 없기 때문이다.
>
> **4. 메서드에 private와 final을 같이 사용할 필요는 없다**
> 접근 제어자가 private인 메서드는 오버라이딩 될 수 없기 때문. 이 둘 중 하나만 사용해도 의미는 충분하다.

</br>
</br>

<코드>

```java
class Participant { // 출연자 클래스
    // private 접근 제어자를 이용한 변수 선언 (외부에서 접근할 수 없도록! 출연자들 개인 정보 보호, 메서드를 통해서만 접근 가능)
    private String name;
    private int age;

    // 생성자
    public Participant(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // 출연자들 정보 출력 메서드
    public void PrintInfo() {
        System.out.println("이름: " + name);
        System.out.println("나이: " + age);
    }
}

// 자식 클래스 (환승연애 출연자)
class ExchangeParticipant extends Participant {

    private String exLover; // 전애인과 함께 나오는 프로그램이므로 전애인 변수 추가

    static {
        System.out.println("=== 환승연애 출연자 정보 === ");
    }
    // 클래스 초기화 블록을 이용해 처음 한번만 실행
    // 환승연애 출연자 정보라는 걸 처음 한번만 알리기 위함!

    public ExchangeParticipant(String name, int age, String exLover) {
        // super 키워드를 이용한 부모 클래스(참가자 클래스)의 생성자 호출
        super(name, age);
        this.exLover = exLover;
    }

    // 오버라이딩된 메서드 (환승연애 출연자 이므로 전애인의 정보를 추가적으로 출력해줌)
    // 출연자들의 정보를 출력하는 것은 동일하므로 새로운 메서드를 생성하기 보다는 오버라이딩 이용이 적절
    @Override
    public void PrintInfo() {

        // super 키워드를 이용한 부모 클래스의 메서드 호출 (이름과 나이를 출력하는 부분은 부모클래스와 동일)
        // 중복 코드 줄여주고 후에 변경이 용이 (부모클래스만 변경하면 자식 클래스 자동적으로 전부 변경되므로)
        super.PrintInfo();
        System.out.println("X: " + exLover); // 추가적으로 더해주는 정보만 따로 출력

    }
}

// 메인 클래스
public class Main {
    public static void main(String[] args) {
        // 자식 클래스(환승연애 출연자)의 인스턴스 생성
        ExchangeParticipant p1 = new ExchangeParticipant("서경", 31, "주원");
        ExchangeParticipant p2 = new ExchangeParticipant("유정", 26, "창진");

        // 자식 클래스(환승연애 출연자)의 메서드 호출
        p1.PrintInfo();
        p2.PrintInfo();
    }
}
```

</br>
</br>

> **회고**
> 글 작성할 때는 임시 저장을 틈틈이 하자.. 두번 글 쓴게 날라갔어서 조금 힘들었다.
> 상속과 오버라이딩 부분은 이해하기 쉬웠지만 패키지 부분이 이해하는데 좀 어려움이 있었다. (왜 이용해야하는 지, 어떻게 이용해야 하는지..) 아무래도 책이 윈도우 기준으로 설명되어 있어서 조금 더 어려웠던 것 같다. 나중에 따로 찾아서 다시 제대로 공부해봐야 겠다.
